#!/bin/ksh
# Copyright (c) 2025 Robert August Vincent II <pillarsdotnet@gmail.com>
# Co-author: Cursor-AI.
# Report: (1) % time per activity sorted high to low, (2) hours per day of week (Sunâ€“Sat).
# If the last entry is START (work in progress), infer work has just stopped for the report.

TIMESHEET=~/Documents/timesheet.log
TMP_ACT=/tmp/timesheet_act_$$
TMP_LOG=/tmp/timesheet_log_$$

if [ ! -f "$TIMESHEET" ]; then
  echo "No timesheet data found."
  exit 0
fi

# Build effective log: if last line is START, append STOP|now so the report includes current session
last=$(tail -n 1 "$TIMESHEET" 2>/dev/null)
work_in_progress=false
case "$last" in
  'START|'*)
    work_in_progress=true
    { cat "$TIMESHEET"; echo "STOP|$(date +%s)"; } > "$TMP_LOG"
    ;;
  *)
    cat "$TIMESHEET" > "$TMP_LOG"
    ;;
esac

awk -F'|' '
  function push(e, a) { stack_epoch[++n] = e; stack_act[n] = a }
  function pop(e) {
    if (n < 1) return
    start_epoch = stack_epoch[n]; start_act = stack_act[n]; n--
    dur = e - start_epoch
    if (dur <= 0) return
    act[start_act] += dur
    days = int(start_epoch / 86400); dow = (days + 4) % 7
    dow_sec[dow] += dur
  }
  /^START\|/ {
    if (n >= 1) pop($2)
    push($2, $3)
    next
  }
  /^STOP\|/  { pop($2); next }
  END {
    total = 0; for (a in act) total += act[a]
    if (total == 0) { print "No work recorded."; exit 0 }

    for (a in act) printf "%.1f\t%s\n", 100*act[a]/total, a
  }
' "$TMP_LOG" | sort -rn > "$TMP_ACT"

awk -F'|' '
  function push(e, a) { stack_epoch[++n] = e; stack_act[n] = a }
  function pop(e) {
    if (n < 1) return
    start_epoch = stack_epoch[n]; start_act = stack_act[n]; n--
    dur = e - start_epoch
    if (dur <= 0) return
    act[start_act] += dur
    days = int(start_epoch / 86400); dow = (days + 4) % 7
    dow_sec[dow] += dur
  }
  /^START\|/ {
    if (n >= 1) pop($2)
    push($2, $3)
    next
  }
  /^STOP\|/  { pop($2); next }
  END {
    total = 0; for (a in act) total += act[a]
    if (total == 0) exit 0
    names[0]="Sunday"; names[1]="Monday"; names[2]="Tuesday"; names[3]="Wednesday"
    names[4]="Thursday"; names[5]="Friday"; names[6]="Saturday"
    for (d = 0; d <= 6; d++) printf "%s\t%.2f\n", names[d], dow_sec[d]/3600
  }
' "$TMP_LOG" > "${TMP_ACT}.dow"

# Part 1: activity percentages
if [ -s "$TMP_ACT" ]; then
  awk -F'\t' '{ printf "%.1f%%  %s\n", $1, $2 }' "$TMP_ACT"
fi
# Part 2: hours per day of week
if [ -s "${TMP_ACT}.dow" ]; then
  awk -F'\t' '{ printf "%s  %.2f\n", $1, $2 }' "${TMP_ACT}.dow"
fi

# If work is in progress, append start time, current duration, and description
if [ "$work_in_progress" = true ]; then
  start_epoch=$(echo "$last" | cut -d'|' -f2)
  activity=$(echo "$last" | cut -d'|' -f3-)
  start_time=$(date -r "$start_epoch" 2>/dev/null) || start_time=$(date -d "@$start_epoch" 2>/dev/null) || start_time="?"
  now=$(date +%s)
  duration_sec=$((now - start_epoch))
  duration_min=$((duration_sec / 60))
  duration_hr=$((duration_min / 60))
  duration_rem=$((duration_min % 60))
  if [ "$duration_hr" -gt 0 ]; then
    duration_fmt="${duration_hr}h ${duration_rem}m"
  else
    duration_fmt="${duration_min}m"
  fi
  echo ""
  echo "$start_time + ${duration_fmt}: $activity"
fi

rm -f "$TMP_ACT" "${TMP_ACT}.dow" "$TMP_LOG"
